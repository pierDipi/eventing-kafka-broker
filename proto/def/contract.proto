syntax = 'proto3';

import "google/protobuf/empty.proto";

option go_package = "control-plane/pkg/contract";
option java_package = "dev.knative.eventing.kafka.broker.contract";
option java_outer_classname = "DataPlaneContract";

message Filter {
  // attributes filters events by exact match on event context attributes.
  // Each key in the map is compared with the equivalent key in the event
  // context. An event passes the filter if all values are equal to the
  // specified values.
  //
  // Nested context attributes are not supported as keys. Only string values are supported.
  map<string, string> attributes = 1;
}

// BackoffPolicyType is the type for backoff policies
enum BackoffPolicy {

  // Exponential backoff policy
  Exponential = 0;

  // Linear backoff policy
  Linear = 1;
}

message EgressConfig {
  // Dead letter is where the event is sent when something goes wrong
  string deadLetter = 1;

  // retry is the minimum number of retries the sender should attempt when
  // sending an event before moving it to the dead letter sink.
  //
  // Setting retry to 0 means don't retry.
  uint32 retry = 2;

  // backoffPolicy is the retry backoff policy (linear, exponential).
  BackoffPolicy backoffPolicy = 3;

  // backoffDelay is the delay before retrying in milliseconds.
  uint64 backoffDelay = 4;
}

message Egress {
  // Consumer group name.
  string consumerGroup = 1;

  // Destination is the sink where events are sent.
  string destination = 2;

  oneof replyStrategy {
    // Send the response to an url
    string replyUrl = 3;

    // Send the response to a Kafka topic
    google.protobuf.Empty replyToOriginalTopic = 4;
  }

  Filter filter = 5;

  // Id of the egress. It's the same as the Kubernetes resource uid.
  string uid = 6;

  // Topic names.
  repeated string topics = 7;

  // A comma separated list of host/port pairs to use for establishing the initial connection to the Kafka cluster.
  // Note: we're using a comma separated list simply because that's how java kafka client likes it.
  string bootstrapServers = 8;

  EgressConfig egressConfig = 9;
}

// CloudEvent content mode
enum ContentMode {
  BINARY = 0;
  STRUCTURED = 1;
}

message Ingress {
  // Id of the resource
  // It's the same as the Kubernetes resource uid
  string uid = 1;

  // A comma separated list of host/port pairs to use for establishing the initial connection to the Kafka cluster.
  // Note: we're using a comma separated list simply because that's how java kafka client likes it.
  string bootstrapServers = 2;

  // Topic name.
  string topic = 4;

  // Optional content mode to use when pushing messages to Kafka
  ContentMode contentMode = 5;

  // Ingress can both listen on a specific HTTP path
  // or listen to the / path but match the Host header
  oneof ingressType {
    // path to listen for incoming events.
    string path = 6;

    // host header to match
    string host = 7;
  }
}

// For communicating changes between data plane and control plane we use an internal topic.
// The internal topic is configured to be log compacted so that Apache Kafka keeps only the last message for any given
// key.
//
// For each object we sent a message in the following form:
// Key:   <resource UID>
// Value: <Object>
// where <Object> can be:
//  - Ingress: an Ingress is the minimal configuration for a Broker, a Channel, or a KafkaSink.
//  - Egress: an Egress is the minimal configuration for a Subscription, a Trigger or a KafkaSource.
message Object {
  oneof Object {

    Ingress ingress = 1;

    Egress egress = 2;
  }
}
